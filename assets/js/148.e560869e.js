(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{472:function(a,t,s){"use strict";s.r(t);var r=s(7),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("jvm相关")]),a._v(" "),t("h4",{attrs:{id:"_1-jdk、jre、jvm的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-jdk、jre、jvm的关系"}},[a._v("#")]),a._v(" 1.jdk、jre、jvm的关系")]),a._v(" "),t("h5",{attrs:{id:"_1、jdk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、jdk"}},[a._v("#")]),a._v(" 1、jdk")]),a._v(" "),t("p",[a._v("JDK(Java SE Development Kit)，Java标准开发包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等。")]),a._v(" "),t("h5",{attrs:{id:"_2、jre"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、jre"}},[a._v("#")]),a._v(" 2、jre")]),a._v(" "),t("p",[a._v("JRE( Java Runtime Environment) 、Java运行环境，用于解释执行Java的字节码文件。普通用户而只需要安装 JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。")]),a._v(" "),t("h5",{attrs:{id:"_3、jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、jvm"}},[a._v("#")]),a._v(" 3、jvm")]),a._v(" "),t("p",[a._v("JVM(Java Virtual Mechinal)，Java虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。所有平台的上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。")]),a._v(" "),t("p",[t("strong",[a._v("JDk包含JRE，JDK 和 JRE 中都包含 JVM。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"/chaos_front/img/jvm/jvm.jpg",alt:"jvm"}})]),a._v(" "),t("h4",{attrs:{id:"_2-java执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-java执行流程"}},[a._v("#")]),a._v(" 2.Java执行流程")]),a._v(" "),t("h5",{attrs:{id:"_1-java代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-java代码"}},[a._v("#")]),a._v(" 1.java代码")]),a._v(" "),t("h5",{attrs:{id:"_2-前端编译器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-前端编译器"}},[a._v("#")]),a._v(" 2.前端编译器")]),a._v(" "),t("h5",{attrs:{id:"_3-java字节码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-java字节码"}},[a._v("#")]),a._v(" 3.Java字节码")]),a._v(" "),t("h5",{attrs:{id:"_4-类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-类加载器"}},[a._v("#")]),a._v(" 4.类加载器")]),a._v(" "),t("h5",{attrs:{id:"_5-解释、编译、执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-解释、编译、执行"}},[a._v("#")]),a._v(" 5.解释、编译、执行")]),a._v(" "),t("h4",{attrs:{id:"_3-jvm的架构模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-jvm的架构模型"}},[a._v("#")]),a._v(" 3.jvm的架构模型")]),a._v(" "),t("h5",{attrs:{id:"_1-基于栈的架构模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于栈的架构模型"}},[a._v("#")]),a._v(" 1.基于栈的架构模型")]),a._v(" "),t("p",[a._v("特点不依赖硬件，可移植性好，可以跨平台")]),a._v(" "),t("h5",{attrs:{id:"_2-基于寄存器的架构模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于寄存器的架构模型"}},[a._v("#")]),a._v(" 2.基于寄存器的架构模型")]),a._v(" "),t("p",[a._v("特点依赖硬件，性能更高")]),a._v(" "),t("h4",{attrs:{id:"_4-几种虚拟机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-几种虚拟机"}},[a._v("#")]),a._v(" 4.几种虚拟机")]),a._v(" "),t("h5",{attrs:{id:"_1-sun-classic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-sun-classic"}},[a._v("#")]),a._v(" 1.sun classic")]),a._v(" "),t("h5",{attrs:{id:"_2-exact-jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-exact-jvm"}},[a._v("#")]),a._v(" 2.exact jvm")]),a._v(" "),t("h5",{attrs:{id:"_3-hotspot-主流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-hotspot-主流"}},[a._v("#")]),a._v(" 3.hotspot 主流")]),a._v(" "),t("h5",{attrs:{id:"_4-jrockit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-jrockit"}},[a._v("#")]),a._v(" 4.JRockit")]),a._v(" "),t("h5",{attrs:{id:"_5-ibm-j9"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-ibm-j9"}},[a._v("#")]),a._v(" 5.IBM J9")]),a._v(" "),t("h4",{attrs:{id:"_5-java类加载的七个阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-java类加载的七个阶段"}},[a._v("#")]),a._v(" 5.Java类加载的七个阶段")]),a._v(" "),t("p",[t("img",{attrs:{src:"/chaos_front/img/jvm/load.jpeg",alt:"1669164823978-c5a5afe0-517d-4726-a3dd-60165d9cc6eb"}})]),a._v(" "),t("p",[a._v("加载、验证、准备、解析、初始化、使用、卸载")]),a._v(" "),t("h4",{attrs:{id:"_6-代码块的执行顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-代码块的执行顺序"}},[a._v("#")]),a._v(" 6.代码块的执行顺序")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qq_57421630/article/details/127036231",target:"_blank",rel:"noopener noreferrer"}},[a._v("(25条消息) 【 java 面向对象】代码块以及不同位置对属性赋值的执行顺序_馆主阿牛的博客-CSDN博客"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v("第一步：先执行"),t("strong",[a._v("父类")]),a._v("的"),t("strong",[a._v("静态代码块")])]),a._v(" "),t("p",[a._v("第二步：再执行"),t("strong",[a._v("子类")]),a._v("的"),t("strong",[a._v("静态代码块")])]),a._v(" "),t("p",[a._v("第三步：再执行"),t("strong",[a._v("父类")]),a._v("的"),t("strong",[a._v("代码块")])]),a._v(" "),t("p",[a._v("第四步：再执行"),t("strong",[a._v("父类")]),a._v("的"),t("strong",[a._v("构造方法")])]),a._v(" "),t("p",[a._v("第五步：再执行"),t("strong",[a._v("子类")]),a._v("的"),t("strong",[a._v("代码块")])]),a._v(" "),t("p",[a._v("第六步：再执行"),t("strong",[a._v("子类")]),a._v("的"),t("strong",[a._v("构造方法")])]),a._v(" "),t("h4",{attrs:{id:"_7-帮助理解的一个类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-帮助理解的一个类"}},[a._v("#")]),a._v(" 7.帮助理解的一个类")]),a._v(" "),t("p",[a._v("如果一个属性是静态的，它会按照代码的顺序执行，如果 int A在静态代码块之前，输出的Son.B就是2，如果在静态代码块之后，Son.B就是1.")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("public class Test {\n     static class Father{\n         #public static int A =1;\n        static {\n            A =2;\n        }\n      public static int A =1;\n    }\n    static class Son extends Father{\n        public static int B =A;\n\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Son.B);\n    }\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br")])]),t("h4",{attrs:{id:"_8-类加载器的分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-类加载器的分类"}},[a._v("#")]),a._v(" 8.类加载器的分类")]),a._v(" "),t("h5",{attrs:{id:"_1-引导类加载器-图片中的启动类加载器-用c语言写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-引导类加载器-图片中的启动类加载器-用c语言写"}},[a._v("#")]),a._v(" 1.引导类加载器（图片中的启动类加载器，用C语言写）")]),a._v(" "),t("h5",{attrs:{id:"_2-自定义类加载器-图片中除了启动类加载器-其他的都是自定义加载器-跟图片中的自定义加载器定义范围不一样-用java语言写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-自定义类加载器-图片中除了启动类加载器-其他的都是自定义加载器-跟图片中的自定义加载器定义范围不一样-用java语言写"}},[a._v("#")]),a._v(" 2.自定义类加载器（图片中除了启动类加载器，其他的都是自定义加载器，跟图片中的自定义加载器定义范围不一样，用java语言写）")]),a._v(" "),t("p",[a._v("其中扩展类加载器和系统类加载器都继承了Classloader，引导类加载器和自定义类加载体是包含关系，非继承关系")]),a._v(" "),t("p",[t("img",{attrs:{src:"/chaos_front/img/jvm/shuangqin.webp",alt:"u=49644513,4273250051&fm=253&fmt=auto&app=138&f=JPEG"}})]),a._v(" "),t("h4",{attrs:{id:"_9-双亲委派机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-双亲委派机制"}},[a._v("#")]),a._v(" 9.双亲委派机制")]),a._v(" "),t("p",[t("img",{attrs:{src:"/chaos_front/img/jvm/shuang.png",alt:"image-20221123142651763"}})]),a._v(" "),t("p",[a._v("双亲委派机制存在的意义：\n1.通过委派的方式，可以避免类的重复加载，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。\n2.通过双亲委派的方式，还保证了安全性。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。那么，就可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。")]),a._v(" "),t("h4",{attrs:{id:"_10-在jvm中判断两个class对象是否完全一致。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-在jvm中判断两个class对象是否完全一致。"}},[a._v("#")]),a._v(" 10.在jvm中判断两个class对象是否完全一致。")]),a._v(" "),t("p",[a._v("1.包名完全一致")]),a._v(" "),t("p",[a._v("2.加载这个类的classloader(指的是classloader的实例对象)必须相同")]),a._v(" "),t("h4",{attrs:{id:"_11-jvm的后台线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-jvm的后台线程"}},[a._v("#")]),a._v(" 11.jvm的后台线程")]),a._v(" "),t("p",[a._v("1.虚拟机线程")]),a._v(" "),t("p",[a._v("2.周期任务线程")]),a._v(" "),t("p",[a._v("3.GC线程")]),a._v(" "),t("p",[a._v("4.编译线程")]),a._v(" "),t("p",[a._v("5.信号调度线程")]),a._v(" "),t("h4",{attrs:{id:"_12-pc寄存器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-pc寄存器"}},[a._v("#")]),a._v(" 12.pc寄存器")]),a._v(" "),t("p",[a._v("pc寄存器存储下一条指令的地址，由执行引擎获取地址，调用并执行。")]),a._v(" "),t("p",[a._v("它是唯一一个在内存中没有javaOutofMemoryError的区域")]),a._v(" "),t("p",[a._v("有垃圾回收的区域堆和方法区（元空间）")]),a._v(" "),t("p",[a._v("有可能出现内存溢出错误的区域，方法区、堆、栈")])])}),[],!1,null,null,null);t.default=v.exports}}]);