(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{475:function(v,_,r){"use strict";r.r(_);var n=r(7),t=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"jvm常用调优方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm常用调优方法"}},[v._v("#")]),v._v(" JVM常用调优方法")]),v._v(" "),_("p",[v._v("文章转载自："),_("a",{attrs:{href:"https://blog.csdn.net/ywlmsm1224811/article/details/91872994",target:"_blank",rel:"noopener noreferrer"}},[v._v("(46条消息) JVM常用调优方法_jvm常用调优方式_dragon@oo的博客-CSDN博客"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("strong",[v._v("一、常用调优方法")])]),v._v(" "),_("p",[_("strong",[v._v("1")]),v._v("**、将新对象预留在新生代**")]),v._v(" "),_("p",[v._v("由于 Full GC 的成本要远远高于 Minor GC ，因此尽可能将对象分配在新生代，在JVM 调优中，可以为应用程序分配一个合理的新生代空间，以最大限度避免新对象直接进去老年代。")]),v._v(" "),_("p",[v._v("注意：由于新生代垃圾回收的速度高于老年代回收，因此，将年轻对象预留在新生代有利于提高整体的 GC 效率")]),v._v(" "),_("p",[_("strong",[v._v("2")]),v._v("**、大对象进入老年代**")]),v._v(" "),_("p",[v._v("大对象占用空间多，直接放入新生代中会扰乱新生代GC，新生代空间不足将会把大量的较小的年轻代对象移入到老年代中，这对GC来说是相当不利的。如果有短命大对象，对GC来说将会是一场灾难，原本存放于老年代的永久对象，被短命大对象塞满，扰乱了分代内存回收的基本思路，因此，在开发过程中，尽可能避免使用短命的大对象。使用参数 -XX：PretenureSizeThreshold 设置大对象直接进入老年代的阀值，当对象超过这个阀值时，将直接在老年代中分配。其中， -XX：PretenureSizeThreshold 只对串行收集器和新生代并行收集器有效，并行回收收集器不识别这个参数。")]),v._v(" "),_("p",[v._v("注意：短命的大对象对垃圾回收是一场灾难，目前木有一种特别好的回收方法处理这个问题，因此尽可能避免使用短命的大对象。")]),v._v(" "),_("p",[_("strong",[v._v("3")]),v._v("**、设置对象进入老年代的年龄**")]),v._v(" "),_("p",[v._v("在堆中每个对象都有自己的年龄，如果对象在 eden 区，经过一次 GC 后还存活，则被移动到 survivor 区中，对象年龄加 1，以后每经过一次 GC 依然存活的，对象年龄就加 1。当对象年龄达到阀值时，就移动到老年代，这个阀值用以下参数设置：")]),v._v(" "),_("p",[v._v("-XX：MaxTenuringThreshold：默认值是15，这个参数是指定进入老年代的最大年龄值，对象实际进入老年代的年龄是 JVM 在运行时根据内存使用情况动态计算的。")]),v._v(" "),_("p",[v._v("如果希望对象尽可能长地留在新生代中，可以设置一个较大的阀值。")]),v._v(" "),_("p",[_("strong",[v._v("4")]),v._v("**、稳定与震荡的堆大小**")]),v._v(" "),_("p",[v._v("稳定的堆大小对垃圾回收是有利的，获得一个稳定堆大小的方法就是设置 -Xmx 和 -Xms 一样的值。不稳定的堆也不是木有用处，让堆大小在一个区间内震荡，在系统不需要使用大内存时压缩堆空间，使 GC 应对一个较小的堆，可以加快单次 GC 的速度。基于这种思想，JVM 提供了两个参数用于压缩和扩展堆空间，参数如下：")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：MinHeapFreeRatio**：设置堆空间最小空闲比例，默认是 "),_("strong",[v._v("40")]),v._v(" ，当堆空间的空闲比例小于这个值时，JVM 便会扩展堆空间")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：MaxHeapFreeRatio**：设置堆空间的最大空闲比例，默认是 "),_("strong",[v._v("70")]),v._v("，当堆空间的空闲比例大于这个值时，JVM 便会压缩堆空间，得到一个较小的堆")]),v._v(" "),_("p",[v._v("注意：当 -Xms 和 -Xmx 相等时，-XX：MinHeapFreeRatio 和 -XX：MaxHeapFreeRatio 这两个参数无效")]),v._v(" "),_("p",[_("strong",[v._v("5")]),v._v("**、吞吐量优先设置**")]),v._v(" "),_("p",[v._v("机器配置是 4G 内存 和 32 核 CPU，配置参数如下：")]),v._v(" "),_("p",[_("strong",[v._v("-Xms3800m  -Xmx3800m")]),v._v("**（堆的初始值和最大值一样）**")]),v._v(" "),_("p",[_("strong",[v._v("-Xmn2g")]),v._v("**（新生代大小）**")]),v._v(" "),_("p",[_("strong",[v._v("-Xss128k")]),v._v("**（线程栈大小，减少它使剩余的系统内存支持更多的线程）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+UseParallelGC****（新生代使用并行回收收集器）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：ParallelGCThreads=20****（垃圾回收的线程数）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+UseParallelOldGC** "),_("strong",[v._v("（老年代使用并行回收收集器）")])]),v._v(" "),_("p",[_("strong",[v._v("6")]),v._v("**、使用大页案例**")]),v._v(" "),_("p",[v._v("使用大的内存分页可以增强 CPU 的内存寻址能力，从而提高系统的性能，参数设置如下：")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：LargePageSizeInBytes**：设置大页的大小")]),v._v(" "),_("p",[_("strong",[v._v("7")]),v._v("**、降低停顿案例**")]),v._v(" "),_("p",[v._v("为了降低应用软件在垃圾回收时的停顿，首先考虑的使用关注系统停顿的 CMS 回收器，为了减少 Full GC 的次数，应尽可能将对象预留在新生代，新生代 Minor GC 的成本远远小于老年代的 Full GC")]),v._v(" "),_("p",[_("strong",[v._v("-Xms3800m  -Xmx3800m")]),v._v("**（堆的初始值和最大值一样）**")]),v._v(" "),_("p",[_("strong",[v._v("-Xmn2g")]),v._v("**（新生代大小）**")]),v._v(" "),_("p",[_("strong",[v._v("-Xss128k")]),v._v("**（线程栈大小，减少它使剩余的系统内存支持更多的线程）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：ParallelGCThreads=20****（垃圾回收的线程数）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+UseConcMarkSweepGC****（老年代使用 CMS 收集器）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+UseParNewGC****（新生代使用并行收集器）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：SurvivorRatio=8****（设置 eden ： survivor = 8 : 1）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：TargetSurvivorRatio****（设置 survivor 的使用率为 90%，默认是50%，提高了survivor 区的使用率，当存放的对象超过这个数值，则对象会向老年代压缩）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：MaxTenuringThreshold=31****（设置年轻对象晋升到老年代的最大年龄是31，默认是15，设为31是尽可能地将对象留在新生代）**")]),v._v(" "),_("p",[_("strong",[v._v("二、常用JVM参数")])]),v._v(" "),_("p",[_("strong",[v._v("1")]),v._v("**、JIT编译参数**")]),v._v(" "),_("p",[v._v("JVM 的 JIT（Just-In-Time）编译器，可以在运行时将字节码编译成本地代码，从而提高函数的执行效率。参数设置如下")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：CompileThreshold**：JIT 编译的阀值，当函数的调用超过这个值时，JIT 就将字节码编译成本地机器码。在 client 模式下，取值是 1500，在 server 模式下，取值是 10000")]),v._v(" "),_("p",[_("strong",[v._v("2")]),v._v("**、堆快照（堆 Dump）**")]),v._v(" "),_("p",[v._v("在性能问题排查中，分析堆快照（Dump）是必不可少的一环。获取程序的堆快照文件有多种方法，下面介绍一种常用的方法，即使用 -XX：+HeapDumpOnOutOfMemoryError 参数在程序发生 OOM 时，导出应用程序的当前堆快照。这是一种非常有效的方法，因为当程序发生 OOM 退出系统时，一些瞬时信息都随着程序的终止而消失，而重现 OOM 问题往往比较困难或者耗时，因此当发生 OOM 时，将堆信息保存到文件中是至关重要的，通过下面的参数设置：")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+HeapDumpOnOutOfMemoryError（开启堆快照）**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：HeapDumpPath=C:/m.hprof（保存文件到哪个目录）**")]),v._v(" "),_("p",[v._v("导出的 Dump 文件可以通过 Visual VM 等多种工具查看分析，进而定位问题，如下图所示：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190613163604636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3bG1zbTEyMjQ4MTE=,size_16,color_FFFFFF,t_70",alt:""}})]),v._v(" "),_("p",[_("strong",[v._v("3")]),v._v("**、错误处理**")]),v._v(" "),_("p",[v._v("系统发生 OOM 错误时，JVM 在错误发生时运行一段第三方脚本，重置系统，设置参数如下：")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：OnOutOfMemoryError=C:\\reset.bat**")]),v._v(" "),_("p",[_("strong",[v._v("4")]),v._v("**、获取 GC 信息**")]),v._v(" "),_("p",[v._v("获取 GC 信息是 java 应用程序调优最重要的一环，下面介绍一些常用的设置参数：")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+PrintGC（-verbose：gc）：**"),_("strong",[v._v("输出打印简要的 GC 信息，包括 GC 前的堆栈情况和 GC 后的堆栈大小和堆栈的总大小")])]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+PrintGCDetails：**"),_("strong",[v._v("输出打印详细的 GC 信息，不仅包括基本信息，还给出了新生代、老年代和永久区各自的 GC 信息")])]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+PrintGCTimeStamps：**"),_("strong",[v._v("额外输出 GC 发生的时间，可以推断出 GC 的频率和间隔")])]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+PrintTenuringDistribution  -XX：MaxTenuringThreshold=18：**"),_("strong",[v._v("查看新生代晋升老年代的实际阀值（-XX：+PrintTenuringDistribution），设置的最大年龄为18（ -XX：MaxTenuringThreshold=18）")])]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+PrintHeapAtGC：**"),_("strong",[v._v("每次 GC 时都会打印堆的详细使用情况，输出量很巨大。它分为两个部分：GC 前的堆信息和 GC 后的堆信息，这里包含了新生代、老年代和永久区的使用大小和使用率，还包括了新生代中 eden 区和 survivor 区的使用情况")])]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+PrintGCApplicationStoppedTime：**"),_("strong",[v._v("应用程序在 GC 发生时的停顿时间")])]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+PrintGCApplicationConcurrentTime：**"),_("strong",[v._v("应用程序在 GC 停顿期间的执行时间")])]),v._v(" "),_("p",[_("strong",[v._v("-Xloggc")]),v._v("**：C:/gc.log：**"),_("strong",[v._v("将 GC 日志信息输出到具体位置的文件中，便于日后日志分析")])]),v._v(" "),_("p",[_("strong",[v._v("注意：详细的 GC 信息是进行 JVM 调优的重要参考信息，可以根据 GC 日志，设置合理的堆大小及相关垃圾回收器的参数")])]),v._v(" "),_("p",[_("strong",[v._v("5")]),v._v("**、类和对象跟踪**")]),v._v(" "),_("p",[v._v("JVM 提供了一组参数，用于获取系统运行时加载、卸载类的信息，参数设置如下：")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：TraceClassLoading**：跟踪类加载情况")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：TraceClassUnloading**：跟踪类的卸载情况")]),v._v(" "),_("p",[_("strong",[v._v("-verbose")]),v._v("**：class**：相当于同时设置  -XX：TraceClassLoading 和 -XX：TraceClassUnloading 两个参数")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+PrintClassHistogram**：打印运行时实例的信息，当设置此参数后，使用 Ctrl +    Break 会输出系统内类的统计信息，从左到右依次显示了序号、实例数量、总大小和类名等信息")]),v._v(" "),_("p",[_("strong",[v._v("6")]),v._v("**、控制GC**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：DisableExplicitGC**：禁止 GC 操作，即禁止在程序中使用 System.gc() 触发 Full GC")]),v._v(" "),_("p",[_("strong",[v._v("-Xnoclassgc")]),v._v("：禁止类的回收")]),v._v(" "),_("p",[_("strong",[v._v("-Xingc")]),v._v("**：**"),_("strong",[v._v("增量式的 GC ，增量式的 GC 使用特定的算法让 GC 线程和应用程序线程交叉执行，从而减少应用程序因 GC 产生的停顿时间")])]),v._v(" "),_("p",[_("strong",[v._v("-Xverify")]),v._v("**：none**：关闭类校验器")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：+UseLargePages****：启用大页，使用大页后，内存分页的表项就会减少，从而提升CPU从虚拟内存地址映射到物理内存地址的能力**")]),v._v(" "),_("p",[_("strong",[v._v("-XX")]),v._v("**：LargePageSizeInBytes****：指定大页的大小**")]),v._v(" "),_("h3",{attrs:{id:"三、触发gc的条件和解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、触发gc的条件和解决方案"}},[v._v("#")]),v._v(" 三、触发gc的条件和解决方案")]),v._v(" "),_("p",[_("strong",[v._v("1、System.gc()方法的调用")])]),v._v(" "),_("p",[v._v("system.gc(), 此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。")]),v._v(" "),_("p",[v._v("解决方案：强烈建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过**-XX:+ DisableExplicitGC**来禁止RMI调用System.gc。")]),v._v(" "),_("p",[_("strong",[v._v("2、老年代代空间（old/Tenured）不足")])]),v._v(" "),_("p",[v._v("老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的Full GC")]),v._v(" "),_("p",[v._v("解决方案：调优时应尽量做到"),_("strong",[v._v("让对象在Minor GC阶段被回收")]),v._v("、让对象在新生代多存活一段时间及不要创建过大的对象及数组")]),v._v(" "),_("p",[_("strong",[v._v("3、永久区(perm)或者元数据区（matespace）空间不足(jdk<=7 ，在jdk8里面是metaspace)")])]),v._v(" "),_("p",[v._v("JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space")]),v._v(" "),_("p",[v._v("解决方案：为避免Perm Gen占满造成Full GC现象，可采用的方法为"),_("strong",[v._v("增大Perm Gen空间或转为使用CMS GC")])]),v._v(" "),_("p",[_("strong",[v._v("4、CMS GC时出现promotion failed和concurrent mode failure")])]),v._v(" "),_("p",[v._v("对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC）。")]),v._v(" "),_("p",[v._v("解决方案："),_("strong",[v._v("增大survivor space、老年代空间或调低触发并发GC的比率(-XX:CMSInitiatingOccupancyFraction=70，预留空间为70%)")]),v._v("，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX: CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。")]),v._v(" "),_("p",[_("strong",[v._v("5、统计得到的Minor GC晋升到旧生代(Eden到S2和S1到S2的和)的平均大小大于老年代的剩余空间")])]),v._v(" "),_("p",[v._v("这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。例如程序第一次触发Minor GC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。当新生代采用PS GC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。")]),v._v(" "),_("p",[v._v("解决方案：通过在启动时通过**- java -Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC**来禁止RMI调用System.gc。")]),v._v(" "),_("p",[_("strong",[v._v("6、堆中分配很大的对象")])]),v._v(" "),_("p",[v._v("所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。")]),v._v(" "),_("p",[v._v("解决方案：为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即**-XX:+UseCMSCompactAtFullCollection**开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，空间碎片问题没有了，但停顿时间不得不变长了，JVM设计者们还提供了另外一个参数 "),_("strong",[v._v("-XX:CMSFullGCsBeforeCompaction")]),v._v(",这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的")])])}),[],!1,null,null,null);_.default=t.exports}}]);