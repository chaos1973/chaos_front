(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{411:function(t,a,n){"use strict";n.r(a);var r=n(7),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"transactional注解与try-catch-exception-e-同时使用事务控制无效问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transactional注解与try-catch-exception-e-同时使用事务控制无效问题"}},[t._v("#")]),t._v(" @Transactional注解与try{}catch(Exception e){}同时使用事务控制无效问题")]),t._v(" "),a("p",[t._v("原文链接："),a("a",{attrs:{href:"https://blog.csdn.net/moke_ant/article/details/104994442",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/moke_ant/article/details/104994442"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("1.@Transactional的使用"),a("br"),t._v("\n通常我们使用注解事务是配置文件开启注解驱动，在相关的类或是方法上通过@Transaction注解的方式使用事务。"),a("br"),t._v("\n2.@Transactional 使用注意点"),a("br"),t._v("\n注解只有在抛出RuntimeException 或者是Erroe时从才会触发事务的回滚，常见的非RuntimeException是不会触发事务的回滚的。"),a("br"),t._v("\n但是我们平时做业务处理时，需要捕获异常，即在方法中使用try{}catch(Exception e){},此时在方法上在使用@Transactional注解， 方法出现异常也不会进行回滚。"),a("br"),t._v("\n同理 在其他文章或是解答中有建议使用@Transactional(rollbackFor = Exception.class) 进行事务的回滚，亲测此方法也是不行的，如果你的方法中有使用到了其他异常或是自定义的异常，同样事务也是不会回滚的。"),a("br"),t._v("\n最后的解决方法是在catch中进行手动的事务回滚。具体案例如下代码"),a("br"),t._v(" "),a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200320172403321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21va2VfYW50,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),a("br"),t._v("\n本人的理解是 在方法中已经进行try catch 即捕获异常并且把异常进行处理了。异常的生命周期已经结束，而并没有将异常抛出所以@Transtaction 注解并没有能监听到异常 所以 注解没哟起到事务回滚的作用")])])}),[],!1,null,null,null);a.default=e.exports}}]);